desc:AnaTape v1.2.0. (by Rathje)

slider1:8<0,24,0.1>Drive (dB)
slider2:20000<2000,20000,100>High Cut (Hz)
slider3:2<0,12,0.1>Head Bump (dB)
slider4:0<0,2,1{30 ips (Hi-Fi),15 ips (Standard),7.5 ips (Vintage)}>Tape Speed
slider5:5<0,100,1>Tape Age / Wear (%)
slider6:25<0,100,1>Wow & Flutter (%)
slider7:0<0,1,1{Off,4x Oversampling}>Oversampling
slider8:1<0,1,1{Off,On}>Auto-Gain
slider9:0<-24,24,0.1>Output Trim (dB)


@init
delay_pos = 0; delay_size = srate * 0.1;
buf_l = 0; buf_r = delay_size + 1;
in_peak = 0.01; out_peak = 0.01; gain_coeff = 1;

@slider
drive_gain = 2 ^ (slider1 / 6.02);
out_trim = 2 ^ (slider9 / 6.02);
age = slider5 / 100;

// HEAD BUMP LOGIC based on tape speed
// 30 ips = 110Hz, 15 ips = 80Hz, 7.5 ips = 60Hz
hb_freq = (slider4 == 0 ? 110 : (slider4 == 1 ? 80 : 60)) + (age * 40);
hb_alpha = 1 - exp(-2 * $pi * hb_freq / srate);
// 30 ips has a less explicit bump
hb_mult = (slider4 == 0 ? 0.7 : (slider4 == 1 ? 1.0 : 1.3));
hb_boost = (2 ^ ((slider3 + (age * 2)) / 6.02) - 1) * hb_mult;

lp_alpha = 1 - exp(-2 * $pi * slider2 / srate);
wow_speed = 0.5 * $pi / srate;
flutter_speed = 8.0 * $pi / srate;
wf_depth = (slider6 / 100) * 0.001 * srate;

@sample
// 1. WOW & FLUTTER 
wf_speed_mod = (slider4 == 0 ? 0.5 : (slider4 == 1 ? 1.0 : 1.5));
phase_wow += wow_speed * wf_speed_mod; 
phase_flutter += flutter_speed * wf_speed_mod;
mod = sin(phase_wow)*0.7 + sin(phase_flutter)*0.3;
current_delay = (wf_depth * mod * wf_speed_mod) + (wf_depth * 1.1);

buf_l[delay_pos] = spl0; buf_r[delay_pos] = spl1;
read_pos = delay_pos - current_delay;
read_pos < 0 ? read_pos += delay_size;
i_pos = floor(read_pos); f_pos = read_pos - i_pos;
s0 = buf_l[i_pos]*(1-f_pos) + buf_l[(i_pos+1)%delay_size]*f_pos;
s1 = buf_r[i_pos]*(1-f_pos) + buf_r[(i_pos+1)%delay_size]*f_pos;
delay_pos = (delay_pos + 1) % delay_size;

// 2. PEAK MEASUREMENT
abs_in = max(abs(s0), abs(s1));
in_peak = (abs_in > in_peak) ? abs_in : in_peak * 0.99999;

// 3. HEAD BUMP
hb_l += hb_alpha * (s0 - hb_l); hb_r += hb_alpha * (s1 - hb_r);
s0 += hb_l * hb_boost; s1 += hb_r * hb_boost;

// 4. DRIVE & SATURATION
s0 *= drive_gain; s1 *= drive_gain;
s0 = atan(s0); s1 = atan(s1);

// 5. TAPE SPEED & AGE TREBLE-LOSS
// 30 ips (slider4=0)gives almost zero loss.
speed_loss = (slider4 == 0 ? 0.5 : (slider4 == 1 ? 2.0 : 5.0));
loss_db = (slider1 * 0.05) + speed_loss + (age * 10);

// Move the HF filter up when using 30 ips
hf_base = (slider4 == 0 ? 19000 : (slider4 == 1 ? 16000 : 12000));
hf_freq = hf_base - (age * 8000);
hf_alpha = 1 - exp(-2 * $pi * hf_freq / srate);

hf_l += hf_alpha * (s0 - hf_l); hf_r += hf_alpha * (s1 - hf_r);
s0 += (hf_l - s0) * (1 - 2 ^ (-loss_db / 20));
s1 += (hf_r - s1) * (1 - 2 ^ (-loss_db / 20));

// 6. MASTER HIGH CUT & OUTPUT
lp_l += lp_alpha * (s0 - lp_l); lp_r += lp_alpha * (s1 - lp_r);
abs_out = max(abs(lp_l), abs(lp_r));
out_peak = (abs_out > out_peak) ? abs_out : out_peak * 0.99999;
match_gain = (slider8 == 1) ? (in_peak / max(out_peak, 0.0001)) : (1 / drive_gain);
gain_coeff += 0.001 * (match_gain - gain_coeff);

spl0 = lp_l * gain_coeff * out_trim;
spl1 = lp_r * gain_coeff * out_trim;
